'use strict';

const clamp = require('lodash/clamp');
const defaultTo = require('lodash/defaultTo');
const lumo = require('lumo');
const ColorRamp = require('../color/ColorRamp');

const SHADER = {
	vert:
		`
		precision highp float;

		attribute vec2 aPosition;
		attribute vec2 aTextureCoord;
		uniform vec2 uTileOffset;
		uniform float uScale;
		uniform mat4 uProjectionMatrix;

		varying vec2 vTextureCoord;

		void main() {
			vTextureCoord = aTextureCoord;
			vec2 wPosition = (aPosition * uScale) + uTileOffset;
			gl_Position = uProjectionMatrix * vec4(wPosition, 0.0, 1.0);
		}
		`,
	frag:
		`
		precision highp float;

		uniform float uOpacity;
		uniform float uRangeMin;
		uniform float uRangeMax;
		uniform float uMin;
		uniform float uMax;
		uniform sampler2D uTextureSampler;
		uniform sampler2D uColorRampSampler;
		uniform float uColorRampSize;

		varying vec2 vTextureCoord;

		float decodeRGBAToFloat(vec4 v) {
			return
				(v.x * 255.0) +
				(v.y * 255.0 * 256.0) +
				(v.z * 255.0 * 65536.0) +
				(v.w * 255.0 * 16777216.0);
		}

		float log10(float val) {
			return log(val) / log(10.0);
		}

		float log10Transform(float val, float minVal, float maxVal) {
			if (minVal < 1.0) { minVal = 1.0; }
			if (maxVal < 1.0) { maxVal = 1.0; }
			if (val < 1.0) { val = 1.0; }
			float logMin = log10(minVal);
			float logMax = log10(maxVal);
			float logVal = log10(val);
			float range = logMax - logMin;
			if (range == 0.0) { range = 1.0; }
			return (logVal - logMin) / range;
		}

		float sigmoidTransform(float val, float minVal, float maxVal) {
			minVal = abs(minVal);
			maxVal = abs(maxVal);
			float dist = max(minVal, maxVal);
			float SIGMOID_SCALE = 0.15;
			float scaledVal = val / (SIGMOID_SCALE * dist);
			return 1.0 / (1.0 + exp(-scaledVal));
		}

		float linearTransform(float val, float minVal, float maxVal) {
			float range = maxVal - minVal;
			if (range == 0.0) { range = 1.0; }
			return (val - minVal) / range;
		}

		float transform(float val) {
			val = clamp(val, uMin, uMax);
			#ifdef LINEAR_TRANSFORM
				return linearTransform(val, uMin, uMax);
			#else
				#ifdef SIGMOID_TRANSFORM
					return sigmoidTransform(val, uMin, uMax);
				#else
					return log10Transform(val, uMin, uMax);
				#endif
			#endif
		}

		float interpolateToRange(float nval) {
			float rval = (nval - uRangeMin) / (uRangeMax - uRangeMin);
			return clamp(rval, 0.0, 1.0);
		}

		vec4 colorRamp(float value) {
			float maxIndex = uColorRampSize * uColorRampSize - 1.0;
			float lookup = value * maxIndex;
			float x = mod(lookup, uColorRampSize);
			float y = floor(lookup / uColorRampSize);
			float pixel = 1.0 / uColorRampSize;
			float tx = (x / uColorRampSize) + (pixel * 0.5);
			float ty = (y / uColorRampSize) + (pixel * 0.5);
			return texture2D(uColorRampSampler, vec2(tx, ty));
		}

		void main() {
			vec4 enc = texture2D(uTextureSampler, vTextureCoord);
			float count = decodeRGBAToFloat(enc);
			if (count == 0.0) {
				discard;
			}
			float nval = transform(count);
			float rval = interpolateToRange(nval);
			vec4 color = colorRamp(rval);
			gl_FragColor = vec4(color.rgb, color.a * uOpacity);
		}
		`
};

const createQuad = function(gl, min, max) {
	const vertices = new Float32Array(24);
	// positions
	vertices[0] = min;	vertices[1] = min;
	vertices[2] = max;	vertices[3] = min;
	vertices[4] = max;	vertices[5] = max;
	vertices[6] = min;	vertices[7] = min;
	vertices[8] = max;	vertices[9] = max;
	vertices[10] = min;	vertices[11] = max;
	
	// uvs
	vertices[12] = 0;	vertices[13] = 0;
	vertices[14] = 1;	vertices[15] = 0;
	vertices[16] = 1;	vertices[17] = 1;
	vertices[18] = 0;	vertices[19] = 0;
	vertices[20] = 1;	vertices[21] = 1;
	vertices[22] = 0;	vertices[23] = 1;

	// create quad buffer
	return new lumo.VertexBuffer(
		gl,
		vertices,
		{
			0: {
				size: 2,
				type: 'FLOAT',
				byteOffset: 0
			},
			1: {
				size: 2,
				type: 'FLOAT',
				byteOffset: 2 * 6 * 4
			}
		},
		{
			count: 6,
		});
};

const createTriangle = function(gl, points) {
	
	// create triangles buffer
	return new lumo.VertexBuffer(
		gl,
		points,
		{
			0: {
				size: 2,
				type: 'FLOAT',
				byteOffset: 0
			}
		},
		{
			count: 3,
		});
}

const createTriangles = function(gl, min, max) {
	
	const triangles = new Array(4);
	const vertices = new Float32Array(6);

	const c = (min + max) / 2;

	// left
	vertices[0] = min;	vertices[1] = min;
	vertices[2] = c;	vertices[3] = c;
	vertices[4] = min;	vertices[5] = max;
	
	triangles[0] = createTriangle(gl, vertices);

	// right
	vertices[0] = max;	vertices[1] = min;
	vertices[2] = c;	vertices[3] = c;
	vertices[4] = max;	vertices[5] = max;

	triangles[1] = createTriangle(gl, vertices);

	// top
	vertices[0] = min;	vertices[1] = min;
	vertices[2] = c;	vertices[3] = c;
	vertices[4] = max;	vertices[5] = min;

	triangles[2] = createTriangle(gl, vertices);

	// bottom
	vertices[0] = min;	vertices[1] = max;
	vertices[2] = c;	vertices[3] = c;
	vertices[4] = max;	vertices[5] = max;

	triangles[3] = createTriangle(gl, vertices);

	return triangles;
}


const addTransformDefine = function(shader ,transform) {
	const define = {};
	switch (transform) {
		case 'linear':
			define.LINEAR_TRANSFORM = 1;

		case 'sigmoid':
			define.SIGMOID_TRANSFORM = 1;

		default:
			define.LOG_TRANSFORM = 1;
	}
	shader.define = define;
	return shader;
};

const createRampTexture = function(gl, type) {

	const table = ColorRamp.getTable(type);
	const size = Math.sqrt(table.length / 4);
	const texture = new lumo.Texture(gl, null, {
		filter: 'NEAREST'
	});
	texture.bufferData(table, size, size);

	return texture;
};

class Heatmap extends lumo.WebGLTextureRenderer {

	constructor(options = {}) {
		options.filter = 'NEAREST';
		super(options);
		this.transform = defaultTo(options.transform, 'log10');
		this.range = defaultTo(options.range, [0, 1]);
		this.colorRamp = defaultTo(options.colorRamp, 'verdant');
		// this.tri = null;
		this.triangles = null;
		this.quad = null;
		this.shader = null;
		// this.array = null;
		this.array = new Array(4);
		for (let i = 0; i < 4; ++i) {
			this.array[i] = null;
		}

		this.ramp = null;
	}

	addTile(array, tile) {

		// console.log(tile.data);
		// if (tile.data === null)
		// 	console.log("null");

		// update chunksize if layer resolution changes
		// if (this.array.chunkSize !== this.layer.resolution) {
		// 	this.array.chunkSize = this.layer.resolution;
		// }
		for (let i = 0; i < 4; ++i) {
			if (this.array[i].chunkSize !== this.layer.resolution) {
				this.array[i].chunkSize = this.layer.resolution;
			}

			// const td = new Uint8Array(Math.floor((Math.random() * 9) + 1));
			const t = Math.floor((Math.random() * 10) + 1);
			let td = new Uint8Array(tile.data);
			if (td[0] !== 0) {
				td = [t,0,0,0];
				// console.log(td);	
			}

			// this.array[i].set(tile.coord.hash, new Uint8Array(tile.data));	
			this.array[i].set(tile.coord.hash, new Uint8Array(td));	
		}
		// const td = new Uint8Array(tile.data);
		// console.log(td);
		// array.set(tile.coord.hash, new Uint8Array(tile.data));
		// console.log(array);
	}

	removeTile(array, tile) {
		for (let i = 0; i < 4; ++i) {
			this.array[i].delete(tile.coord.hash);
		}
	}

	onAdd(layer) {
		super.onAdd(layer);

		this.triangles = createTriangles(this.gl, 0, layer.plot.tileSize);

		//this.tri = createTriangle(this.gl, 0, layer.plot.tileSize);
		//this.tri = createTriangles(this.gl, 0, layer.plot.tileSize);
		// this.quad = createQuad(this.gl, 0, layer.plot.tileSize);
		this.shader = this.createShader(
			addTransformDefine(SHADER, this.transform));
		// this.array = this.createTextureArray(layer.resolution);
		for (let i = 0; i < 4; ++i) {
			this.array[i] = this.createTextureArray(layer.resolution);
		}
		this.ramp = createRampTexture(this.gl, this.colorRamp);
		return this;
	}

	onRemove(layer) {
		this.destroyTextureArray(this.array);
		
		this.triangles[0] = null;
		this.triangles[1] = null;
		this.triangles[2] = null;
		this.triangles[3] = null;
		this.triangles = null;

		// this.tri = null;
		// this.quad = null;
		this.shader = null;
		for (let i = 0; i < 4; ++i) {
			this.array[i] = null;
		}
		// this.array = null;
		super.onRemove(layer);
		return this;
	}

	setTransform(transform) {
		this.transform = transform;
		// re-compile shader
		this.shader = this.createShader(
			addTransformDefine(SHADER, this.transform));
	}

	getTransform() {
		return this.transform;
	}

	setValueRange(min, max) {
		this.range = [
			clamp(min, 0, 1),
			clamp(max, 0, 1)
		];
	}

	getValueRange() {
		return [
			this.range[0],
			this.range[1]
		];
	}

	setColorRamp(colorRamp) {
		this.colorRamp = colorRamp;
		this.ramp = createRampTexture(this.gl, this.colorRamp);
	}

	getColorRamp() {
		return this.colorRamp;
	}

	getColorRampFunc() {
		return ColorRamp.getFunc(this.colorRamp);
	}

	draw() {

		// var err = new Error();
		// console.log(err.stack);

		const gl = this.gl;
		const shader = this.shader;
		const array = this.array;
		const triangles = this.triangles;
		// const tri = this.tri;
		// const quad = this.quad;
		const ramp = this.ramp;
		const renderables = this.getRenderables();
		const proj = this.getOrthoMatrix();
		const extrema = this.layer.getExtrema();

		// bind shader
		shader.use();

		// set uniforms
		shader.setUniform('uProjectionMatrix', proj);
		shader.setUniform('uTextureSampler', 0);
		shader.setUniform('uColorRampSampler', 1);
		shader.setUniform('uColorRampSize', ramp.width);
		shader.setUniform('uOpacity', this.layer.opacity);
		shader.setUniform('uRangeMin', this.range[0]);
		shader.setUniform('uRangeMax', this.range[1]);
		shader.setUniform('uMin', extrema.min);
		shader.setUniform('uMax', extrema.max);

		// console.log(shader);

		// set blending func
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

		let last;
		for (let i = 0; i < 4; ++i) {

			triangles[i].bind();
			ramp.bind(1);

			// console.log('shader: ' + shader + ',triangle: ' + triangles[i] + ',ramp: ' + ramp + ',renderables: ' + renderables);
			// console.log(shader);
			// console.log(ramp);
			// console.log(renderables);

			// for each renderable
			renderables.forEach(renderable => {
				
				const hash = renderable.hash;
				if (last !== hash) {
					// bind texture
					// array.bind(hash, 0);
					array[i].bind(hash, 0);

					last = hash;
				}

				// set tile uniforms
				shader.setUniform('uScale', renderable.scale);
				shader.setUniform('uTileOffset', renderable.tileOffset);

				// console.log('hash: ' + renderable.hash + ', scale: ' + renderable.scale + ', tileOffset: ' + renderable.tileOffset);
				// console.log(renderable.tileOffset);

				// draw
				// tri.draw();
				triangles[i].draw();
				
				// quad.draw();
				// no need to unbind texture
			});

			triangles[i].unbind();
		}

		return this;
	}
}

module.exports = Heatmap;
